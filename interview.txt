# 面试常考知识点示例
面试重点 = {
    "数据结构": ["链表", "树", "图", "堆", "哈希表"],
    "算法": ["排序", "搜索", "动态规划", "贪心算法", "回溯"],
    "Python特性": ["装饰器", "生成器", "上下文管理器", "GIL", "元类"],
    "系统设计": ["OOP设计", "API设计", "数据库设计", "并发处理"],
    "框架相关": ["Django/Flask", "SQLAlchemy", "Celery", "Redis"]
}


什么是 GIL？
	GIL（全局解释器锁）是一个全局互斥锁，它确保在任何时刻只有一个线程在执行 Python 字节码
	
	全局性：整个解释器进程只有一个 GIL
	互斥性：同一时间只有一个线程能持有 GIL
	字节码级别：控制的是 Python 字节码的执行

GIL 的工作原理
	线程需要获取GIL才能执行Python代码
	
	GIL 切换机制
		时间片切换：每执行一定数量的字节码指令后切换
		I/O 操作切换：遇到 I/O 操作时主动释放 GIL
		强制切换：通过信号机制强制线程释放 GIL

GIL 的影响
	CPU 密集型任务： 多线程可能比单线程更慢，因为 GIL 导致线程间频繁切换
	I/O 密集型任务： 多线程明显更快，因为 I/O 等待期间会释放 GIL
	混合方案： 线程池处理I/O，进程池处理CPU任务

GIL 的存在原因
	内存管理安全： Python 使用引用计数进行内存管理
	C 扩展兼容性： 许多 C 扩展假设在单线程环境中运行
	历史遗留问题： 早期计算机多为单核，GIL 简化了实现

规避 GIL 限制的方法：
	使用多进程（推荐）： 每个进程有独立的Python解释器和GIL
	使用异步编程： 将CPU密集型任务委托给线程池
	使用 C 扩展释放 GIL： 在C扩展中手动释放GIL，执行不涉及Python对象的计算
	使用 Jython 或 IronPython： 这些实现没有 GIL，但生态不如 CPython

什么是元类？
	元类是创建类的类，它允许你控制类的创建过程。
	普通类用于创建对象（实例）
	元类用于创建类（类本身也是对象）
	

元类的工作原理
	创建流程
		当使用 class关键字时，Python 内部执行：
			收集类命名空间
			确定元类（默认是 type）
			执行元类的 __new__和 __init__方法

元类的核心方法
	__new__方法： 创建类
	__init__方法： 初始化类
	__prepare__方法（Python 3+）： 准备命名空间

type 和 object 的关系
	type和 object的关系构成了 Python 对象模型的核心基础
	
	object
		Python 中所有类的基类
		位于类型层次结构的最顶层
		本身没有基类
		它的类型是 type
	type
		Python 的元类，用于创建类对象
		同时也是它自身的元类
		继承自 object
		它自己是自己的实例（它的类型是 type）
	
	type 和 object 的循环关系
		type 是 object 的子类（所有类都直接或间接继承自 object）
		object 是 type 的实例（所有类都是 type 的实例）
		type 也是自己的实例
	
	isinstance(X, type)：检查 X 是否是类
	issubclass(X, object)：检查 X 是否是 Python 类
	type(X)：获取 X 的类型
	
	object (所有类的基类) -> type (元类，创建类的类) -> 类 (用户定义的类) -> 实例 (用户创建的对象)



