面试重点 = {
    "数据结构": ["链表", "树", "图", "堆", "哈希表"],
    "算法": ["排序", "搜索", "动态规划", "贪心算法", "回溯"],
    "Python特性": ["装饰器", "生成器", "上下文管理器", "GIL", "元类"],
    "系统设计": ["OOP设计", "API设计", "数据库设计", "并发处理"],
    "框架相关": ["Django/Flask", "SQLAlchemy", "Celery", "Redis"]
}

需要快速查找 → 哈希表
需要维护顺序 → 树（二叉搜索树）
需要频繁插入删除 → 链表
需要处理关系网络 → 图
需要优先级处理 → 堆

需要快速查找 → 先排序，再用二分搜索
优化资源分配 → 动态规划或贪心算法
穷举所有可能性 → 回溯算法（配合剪枝优化）

GIL 全局解释器锁： Python 的"交通警察"
Metaclass 元类： 类的"模具工厂"
Decorator 装饰器： 修改函数/类行为的"包装纸"
Generator 生成器： 节省内存的"惰性序列工厂"
Context Manager 上下文管理器： 资源管理的"自动开关"

OOP设计：如何组织代码？ 类、对象、继承、多态
API设计：如何与外界通信？ RESTful、HTTP方法、JSON
数据库设计：如何存储数据？ 表结构、关系、索引、SQL
并发处理：如何同时做多件事？ 线程、进程、锁、异步

什么是链表（Linked List）？
	链表是一种线性数据结构，元素通过指针连接，不像数组需要连续内存空间。
	就像火车车厢。
	
	单向链表		节点→节点→None		只能向前遍历		栈、队列实现
	双向链表		↔节点↔节点↔			可向前向后遍历		浏览器历史记录
	循环链表		节点→节点→头节点		形成环状结构		轮询调度
	
	动态大小：无需预先分配内存
	高效插入删除：O(1)时间复杂度（在已知位置）
	内存利用：不要求连续内存空间

什么是树（Tree）？
	树是一种分层数据结构，由节点和边组成，每个节点有零个或多个子节点。
	就像家族族谱。
	
	二叉树			每个节点最多2个子节点			搜索、排序
	二叉搜索树(BST)	左子节点 < 父节点 < 右子节点	字典、数据库索引
	平衡树(AVL)		自动保持平衡，搜索高效			需要快速查找的场景
	堆				父节点总是大于/小于子节点		优先队列
	B树				多路搜索树，减少磁盘IO			文件系统、数据库
	
	高效搜索：BST平均O(log n)搜索时间
	层次关系：天然表达组织结构（文件系统、DOM树）
	排序能力：中序遍历得到有序序列

什么是图（Graph）？
	图由顶点（节点）和边（连接）组成，表示对象之间的关系。
	就像社交网络。
	
	图的表示方法：
		方法1：邻接矩阵
		方法2：邻接表（更节省空间）
		方法3：类表示（功能最完整）
	
	关系建模：社交网络、交通路线、网页链接
	路径查找：导航系统的最短路径
	网络分析：推荐系统、社区发现

什么是堆（Heap）？
	堆是一种特殊的完全二叉树，父节点总是大于/小于子节点。
	就像医院急诊排队。
	
	最大堆	父节点 ≥ 子节点	获取最大值
	最小堆	父节点 ≤ 子节点	获取最小值
	
	高效极值操作：O(1)获取最大/最小值
	优先队列：任务调度、Dijkstra算法
	排序算法：堆排序O(n log n)

什么是哈希表（Hash Table）？
	哈希表通过哈希函数将键映射到数组索引，实现快速查找。
	就像图书馆索引卡。
	
	极速查找：平均O(1)时间复杂度
	键值存储：天然适合字典、缓存等场景
	集合操作：快速判断元素是否存在

链表		动态大小，指针连接		插入删除：O(1)		内存管理、LRU缓存
树		层次结构，递归定义		搜索：O(log n)		文件系统、数据库索引
图		关系网络，顶点+边		依算法而定			社交网络、路径规划
堆		快速访问极值			插入删除：O(log n)	任务调度、优先队列
哈希表	键值映射，快速查找		增删查改：O(1)		字典、缓存、集合

什么是排序（Sorting）？
	排序是将一组数据按照特定顺序（升序/降序）重新排列的过程。
	就像整理扑克牌。
	
	常用排序：
		冒泡排序		O(n²)		简单易懂，效率低	教学演示，小数据量
		快速排序		O(n log n)	高效，常用		通用排序，大数据量
		归并排序		O(n log n)	稳定，额外空间		链表排序，外部排序
	
	提高搜索效率：有序数据可以用二分查找
	预处理步骤：很多算法需要先排序

什么是搜索（Searching）？
	搜索是在数据集中查找特定元素的过程。
	就像查字典。
	
	线性搜索：一页页翻找（慢）
	二分搜索：根据字母顺序快速定位（快）
	
	搜索算法分类：
		线性搜索		O(n)		无前提条件	无序小数据集
		二分搜索		O(log n)	必须有序		大型有序数据集
		哈希搜索		O(1)		需要哈希表	键值对查找

什么是动态规划（Dynamic Programming）？
	动态规划通过"记住"子问题的解来避免重复计算，解决复杂问题。
	核心思想：分治 + 记忆化，将大问题分解为小问题，存储小问题的解，避免重复计算。

	优化问题：最短路径、资源分配
	现实应用：股票买卖、文本相似度等

什么是贪心算法（Greedy Algorithm）？
	贪心算法在每一步选择中都采取当前状态下最优的选择，希望导致全局最优解。
	就像找零钱。
	
	贪心 vs 动态规划：
		特点			贪心算法				动态规划
		决策方式		局部最优选择			考虑所有可能性
		效率			通常更快				可能较慢
		结果			不一定全局最优			保证全局最优
		适用问题		具有贪心选择性质的问题	重叠子问题的问题
	
	现实应用：霍夫曼编码、最小生成树。
	
什么是回溯（Backtracking）？
	回溯算法通过尝试所有可能性，当发现当前路径不可能得到解时，回退到上一步重新选择。
	就像走迷宫。
	
	现实应用：组合问题、约束满足。

什么是 GIL？
	GIL（全局解释器锁）是一个全局互斥锁，它确保在任何时刻只有一个线程在执行 Python 字节码
	
	全局性：整个解释器进程只有一个 GIL
	互斥性：同一时间只有一个线程能持有 GIL
	字节码级别：控制的是 Python 字节码的执行

	GIL 的工作原理：
		线程需要获取GIL才能执行Python代码
		
		GIL 切换机制
			时间片切换：每执行一定数量的字节码指令后切换
			I/O 操作切换：遇到 I/O 操作时主动释放 GIL
			强制切换：通过信号机制强制线程释放 GIL

	GIL 的影响：
		CPU 密集型任务： 多线程可能比单线程更慢，因为 GIL 导致线程间频繁切换
		I/O 密集型任务： 多线程明显更快，因为 I/O 等待期间会释放 GIL
		混合方案： 线程池处理I/O，进程池处理CPU任务

	GIL 的存在原因：
		内存管理安全： Python 使用引用计数进行内存管理，防止多线程竞争导致对象引用计数错误
		C 扩展兼容性： 许多 C 扩展假设在单线程环境中运行
		历史遗留问题： 早期计算机多为单核，GIL 简化了实现

	规避 GIL 限制的方法：
		使用多进程（推荐）： 每个进程有独立的 Python 解释器和 GIL
		使用异步编程： 将 CPU 密集型任务委托给线程池
		使用 C 扩展释放 GIL： 在 C 扩展中手动释放 GIL，执行不涉及 Python 对象的计算
		使用 Jython 或 IronPython： 这些实现没有 GIL，但生态不如 CPython

什么是元类？
	元类是创建类的类，它允许你控制类的创建过程。
	普通类用于创建对象（实例）
	元类用于创建类（类本身也是对象）
	
	元类的工作原理：
		当使用 class 关键字时，Python 内部执行：
			收集类命名空间，由 __prepare__方法返回的对象（通常是一个字典），收集类定义中的所有成员（属性和方法），直到类创建完成。
			确定元类（默认是 type）
			执行元类的 __new__ 和 __init__方法
	
	元类的核心方法：
		__prepare__ 方法（Python 3+）： 准备命名空间
		__new__ 方法： 创建类
		__init__ 方法： 初始化类
	
	命名空间（Namespace）：
		命名空间是一个从名称到对象的映射（字典结构）。
		当讨论元类收集类命名空间时，我们指的是在类创建过程中，类定义体（class body）中的属性和方法构成的临时命名空间。
		命名空间的本质是 Python 中用于存储变量名（标识符）与其对应对象的容器，分为三种：
			局部命名空间（函数内部）
			全局命名空间（模块级别）
			类命名空间（类定义体内）
		元类命名空间的特点：
			临时性： 仅在类创建过程中存在，最终会被转换为类的 __dict__
			可定制性： 通过元类的 __prepare__可以返回自定义容器（如 OrderedDict）
			包含所有定义： 包括方法、类变量、__module__等元信息
			可修改： 在 __new__中可对命名空间内容进行增删改查
		示例输出：
			{
				'__module__': '__main__',
				'__qualname__': 'MyClass',
				'attr': 42,
				'method': <function MyClass.method at 0x...>
			}
	type 和 object 的关系
		type 和 object 的关系构成了 Python 对象模型的核心基础。
		
		object
			Python 中所有类的基类
			位于类型层次结构的最顶层
			本身没有基类
			它的类型是 type
		type
			Python 的元类，用于创建类对象
			同时也是它自身的元类
			继承自 object
			它自己是自己的实例（它的类型是 type）
		type 和 object 的循环关系
			type 是 object 的子类（所有类都直接或间接继承自 object）
			object 是 type 的实例（所有类都是 type 的实例）
			type 也是自己的实例
		
		isinstance(X, type)：检查 X 是否是类
		issubclass(X, object)：检查 X 是否是 Python 类
		type(X)：获取 X 的类型
		
		object (所有类的基类) -> type (元类，创建类的类) -> 类 (用户定义的类) -> 实例 (用户创建的对象)

什么是装饰器？
	装饰器（Decorator）是一种高阶函数，用于在不修改原函数代码的情况下，动态扩展函数或类的功能。

	输入：一个函数或类
	输出：修改后的函数或类
	本质：语法糖（@decorator）
	
	常见应用场景：
		日志记录
		性能测试（计时）
		权限校验
		缓存（如@functools.lru_cache）

什么是生成器？
	生成器（Generator）是一种惰性计算的迭代器，通过 yield 关键字逐步产生值，节省内存。
	
	内存高效：逐个生成值，不预存完整序列
	状态保持：每次 yield 后暂停，下次继续执行
	
	生成器表达式： (x*x for x in range(5))
	
	典型应用场景：
		处理大型文件（逐行读取）
		无限序列（如斐波那契数列）
		数据流管道

什么是上下文管理器？
	上下文管理器（Context Manager）可以通过 with 语句管理资源（如文件、锁），确保资源的正确获取和释放。
	
	自动资源管理：进入/退出时自动处理
	异常安全：即使出错也会执行清理
	
	实现方式：
		方法1：类实现 __enter__ 和 __exit__ 进行文件载入 和 异常处理
		方法2：使用 contextlib.contextmanager 装饰器将一个生成器函数快速转换为上下文管理器
			yield 的值是 with 语句中 as 的目标，若不需要返回值，可直接 yield（无参数）
			在 yield 之前的执行相当于 __enter__ 的逻辑
			在 yield 之后的执行相当于 __exit__ 的逻辑，会处理 with 块内抛出的异常，可通过 try/finally 确保资源释放。
	
	常见应用场景：
		文件操作
		数据库连接
		线程锁管理（with threading.Lock()）
		临时环境修改（如 @pytest.fixture）

什么是 OOP 设计？
	OOP（Object-Oriented Programming）面向对象设计。
	OOP 设计是一种编程思想，它把现实世界中的事物抽象成“对象”，并通过对象之间的交互来构建程序。
	核心思想是封装、继承、多态和抽象。
	其目的是提高代码的可重用性、灵活性和可维护性。
	
	核心原则（SOLID）：
		SRP 单一职责		一个类只负责一个功能领域		UserService只处理用户业务逻辑
		OCP 开闭原则		对扩展开放，对修改关闭			通过继承/组合扩展，而非修改原有类
		LSP 里氏替换		子类必须能替换父类				Rectangle和 Square的继承问题
		ISP 接口隔离		多个专用接口优于一个通用接口		分离 Readable和 Writable接口
		DIP 依赖倒置		依赖抽象而非具体实现			依赖 PaymentGateway接口而非具体支付类
	
	OOP 的四大支柱：
		封装（Encapsulation）：将数据（属性）和操作数据的方法（行为）捆绑在一起，并隐藏内部实现细节。
		继承（Inheritance）：一个类（子类）可以继承另一个类（父类）的属性和方法，并添加自己特有的内容。
		多态（Polymorphism）：不同类的对象可以对同一消息（方法调用）做出不同的响应。
		抽象（Abstraction）：隐藏复杂的实现细节，只暴露必要的接口。

什么是 API 设计？
	API（Application programming interface）应用程序接口。
	设计这些接口的规范。包括接口的地址（URL）、请求方法（GET/POST/PUT/DELETE）、需要什么参数、返回什么数据、出错时怎么办。
	在Web开发中，通常指 RESTful API 或 GraphQL API 的设计。
	目标是让 API 直观、一致、可靠且易于使用。
	
	什么是 RESTful？
		RESTful 是一种设计 API 的架构风格。
		RESTful 核心思想：将网络上的任何数据或服务都视为“资源”（Resource），并通过标准的 HTTP 方法（如 GET、POST）来操作这些资源。​
	
	RESTful 的六大核心原则：
		统一接口（Uniform Interface）：所有操作都使用统一的 HTTP 方法和资源标识符（URL）。
		无状态（Stateless）：每个请求必须包含处理该请求所需的全部信息（如认证令牌、资源ID），服务器不保存客户端的状态。
		可缓存（Cacheable）：服务器通过响应头（如 Cache-Control）明确指示哪些响应可以被缓存，以及缓存多久。
		客户端-服务器分离（Client-Server Separation）：客户端负责用户界面和用户体验（如网页、手机App），服务器负责数据处理、业务逻辑和存储。
		分层系统（Layered System）：在客户端和服务器之间可以有多个中间层（如负载均衡器、安全层、缓存层）。
		按需代码（Code-On-Demand，可选）：服务器可以返回可执行代码（如JavaScript）给客户端执行。这个原则很少使用，大多数RESTful API只返回数据（JSON/XML）。

什么是数据库设计？
	数据库设计是规划数据如何存储、组织和关联的“仓库布局图”。
	
	规范化原则
	1NF		原子性，每列不可再分	地址拆分为省、市、详细地址
	2NF		消除部分依赖			订单表中不应存储产品价格
	3NF		消除传递依赖			员工表中部门地址应单独存部门表

	性能优化策略：
		索引策略：对查询条件字段建立索引
		反范式化：适当冗余提高查询性能（如订单表冗余用户名）
		分区表：按时间范围分区大数据表
		读写分离：主库写，从库读

什么是并发处理？
	并发处理是让程序能够“同时”处理多个任务的机制。
	
	Python并发模型对比：
		多线程	共享内存，GIL 限制 CPU 密集型任务	适用 I/O 密集型任务（网络请求、文件操作）
		多进程	独立内存，真并行					适用 CPU 密集型任务（计算、图像处理）
		异步IO	单线程事件循环，高并发 I/O			高并发网络应用（Web 服务器）
		协程		轻量级线程，用户态调度				高并发微服务、爬虫
	
	进程（Process）：
		进程是程序的独立执行实例，拥有独立的内存空间。
		进程间通信（IPC）需要特殊机制（如管道、消息队列）
	线程（Thread）：
		线程是进程内的执行单元，共享进程的内存和资源，但是每个线程需要独立栈内存。
		线程间通信更快，但需注意资源竞争（如多个线程同时修改账户余额）。
	锁（Lock）：
		使用互斥锁（Mutex）或信号量（Semaphore）保护共享资源。
		悲观锁：默认别人会冲突，先锁再操作（如银行默认锁抽屉）。
		乐观锁：假设不会冲突，提交时检查版本号（如客户签字确认时核对余额）。
	异步（Asynchronous）：
		主线程不阻塞，任务完成后通过回调（Callback）或事件通知（Event）返回结果。
		其实是单线程在执行任务，但是等待结果期间可以挂起继续执行别的任务。
		多线程靠"人多力量大"，异步靠"时间管理大师"

什么是 Django / Flask？
	Web 应用框架。
	
	处理HTTP请求/响应
	路由管理、模板渲染
	内置ORM（Django）或扩展支持（Flask-SQLAlchemy）
	快速构建Web应用
	Django"大而全"（自带Admin/ORM），Flask"小而美"（灵活可扩展）
	

什么是 SQLAlchemy？
	Python ORM（对象关系映射）工具。
	
	数据库操作抽象化（用 Python 类映射数据库表）
	支持多种数据库（MySQL/PostgreSQL/SQLite 等）
	提供 Core（SQL表达式）和 ORM 两种使用方式
	避免手写SQL
	支持事务、连接池
	适合复杂查询场景
	

什么是 Celery?
	分布式任务队列。
	
	异步执行耗时任务（如邮件发送、文件处理）
	定时任务（ crontab 替代方案）
	分布式多 worker 处理
	解耦主业务流程
	提高系统响应速度
	需搭配消息代理（Redis/RabbitMQ）

什么是 Redis？
	内存数据结构存储 或者 远程字典缓存服务。
	
	高速缓存（减轻数据库压力）
	支持多种数据结构（String/Hash/Set等）
	发布订阅、分布式锁
	微秒级读写性能
	支持数据持久化
	常作为 Celery 的消息代理

用户访问网页：
	Django/Flask 接收请求
	先查Redis缓存 → 命中则直接返回
	未命中 → 用SQLAlchemy查数据库 → 结果存入Redis
提交订单：
	Django/Flask 处理核心逻辑
	通过 Celery 异步发送订单确认邮件
	Celery 使用 Redis 作为任务队列