Flask 简介：
	Flask 是一个用 Python 编写的轻量级 Web 应用框架。
	Flask 基于 WSGI（Web Server Gateway Interface）和 Jinja2 模板引擎，旨在帮助开发者快速、简便地创建 Web 应用。
	Flask 被称为"微框架"，因为它使用简单的核心，用扩展增加其他功能。

	Flask 的组成
		Flask 应用实例： Flask 的核心是应用实例，通过创建 Flask 对象来初始化应用。
		路由和视图函数： 路由将 URL 映射到视图函数，视图函数处理请求并返回响应。
		模板系统： Flask 使用 Jinja2 模板引擎来渲染 HTML 页面，将数据动态插入到页面中。
		请求和响应： Flask 处理 HTTP 请求并生成响应，支持多种 HTTP 方法（如 GET、POST）。
	
	应用工厂： 应用工厂是一个 Python 函数，它创建并返回一个 Flask 应用实例。这允许你配置和初始化你的应用，并且可以创建多个应用实例。
	配置对象： Flask 应用有一个配置对象，你可以使用它来设置各种配置选项，如数据库连接字符串、调试模式等。
	蓝图： 蓝图是 Flask 中的一个组织代码的方式，它允许你将相关的视图函数、模板和静态文件组织在一起，并且可以在多个应用中重用。
	静态文件： 静态文件是不会被服务器端执行的文件，如 CSS、JavaScript 和图片文件。将静态文件放在 static 文件夹中，Flask 会自动提供服务
	扩展： Flask 有许多扩展，可以添加额外的功能，如数据库集成、表单验证、用户认证等。
	会话： Flask 使用客户端会话来存储用户信息，这允许你在用户浏览你的应用时记住他们的状态。可以使用 Python 内置的 secrets 模块生成一个强随机性的密钥。
	错误处理： Flask 允许你定义错误处理函数，当特定的错误发生时，这些函数会被调用。

Flask 项目结构：
	简单项目结构：适用于小型应用，所有代码集中在一个文件中。
		my_flask_app/
		│
		├── app.py
		└── requirements.txt
		
		app.py： 主要的 Flask 应用文件，包含路由和视图函数的定义。
		requirements.txt： 列出项目的依赖库，用于记录 Flask 和其他包的版本信息。
	
	中型项目结构：将应用分为多个模块，便于管理和扩展。
		my_flask_app/
		│
		├── app/
		│   ├── __init__.py
		│   ├── routes.py
		│   └── models.py
		│
		├── config.py
		├── requirements.txt
		└── run.py
		
		app/： 包含 Flask 应用的主要代码。
			__init__.py： 初始化 Flask 应用和配置扩展。
			routes.py： 定义应用的路由和视图函数。
			models.py： 定义应用的数据模型。
		config.py： 配置文件，包含应用的配置信息。
		requirements.txt： 列出项目的依赖库。
		run.py： 用于启动 Flask 应用。
	
	复杂项目结构：支持更高的模块化，适用于大型应用，包含路由、模型、模板和静态文件目录。
		my_flask_app/
		│
		├── app/
		│   ├── __init__.py
		│   ├── routes/
		│   │   ├── __init__.py
		│   │   ├── main.py
		│   │   └── auth.py
		│   ├── models/
		│   │   ├── __init__.py
		│   │   └── user.py
		│   ├── templates/
		│   │   ├── layout.html
		│   │   └── home.html
		│   └── static/
		│       ├── css/
		│       └── js/
		│
		├── config.py
		├── requirements.txt
		├── migrations/
		│   └── ...
		└── run.py
	
		app/routes/：将不同功能模块的路由分开管理。
			main.py：主模块的路由。
			auth.py：认证相关的路由。
		app/models/：管理数据模型，通常与数据库操作相关。
			user.py：用户模型。
		app/templates/：存放 HTML 模板文件。
		app/static/：存放静态文件，如 CSS 和 JavaScript。
		migrations/：数据库迁移文件，通常与 SQLAlchemy 相关。


路由：
	@app.route('/', [methods], [endpoint], [defaults], [strict_slashes])
		'/'： 将根 URL / 映射到指定的函数，可以匹配动态参数。例如 @app.route('/greet/<name>')。
		methods： 指定允许的 HTTP 方法，如 GET、POST、PUT、DELETE 等。
		endpoint： 自定义路由终点名称（默认是函数名），之后可以用 url_for() 反向生成 URL。
		defaults： 为动态路由提供默认值。例如 @app.route('/posts', defaults={'page': 1})
		strict_slashes： 是否严格匹配末尾斜杠，默认 True，/path 和 /path/ 视为不同 URL。
		redirect_to： 永久重定向到另一个路由。
	动态路径转换器： 
		string		默认（不含斜杠）	/user/<username>
		int			整数				/post/<int:id>
		float		浮点数			/price/<float:amount>
		path		含斜杠的字符串		/static/<path:filename>
		uuid		UUID 字符串		/item/<uuid:item_id>
	路由函数返回：
		字符串： 返回纯文本响应。
		HTML： 返回 HTML 页面。
		JSON： 返回 JSON 数据。
		Response 对象： 自定义响应。
	路由优先级： 
		按照定义的顺序匹配路由，第一个匹配成功的路由将被处理。
		确保更具体的路由放在更一般的路由之前： @app.route('/user/<int:user_id>') 放在 @app.route('/user') 之前。


视图函数： 视图函数是 Flask 应用中的核心部分，它负责处理请求并生成响应。
	定义视图函数： 普通的 Python 函数，它接收请求并返回响应。视图函数通常与路由配合使用，通过装饰器将 URL 映射到视图函数。
	接收请求数据： 可以接收不同类型的请求数据，包括 URL 参数、表单数据、查询参数等。
		request.form.get('username')：获取 POST 请求中表单字段。
		request.args.get('query')：获取 GET 请求中的查询参数。
		request.headers.get('User-Agent')：获取请求头中的 User-Agent 信息。
	返回响应： 可以返回多种类型的响应，包括字符串、HTML、JSON、或自定义响应对象。
		render_template('hello.html', name=name)：渲染 HTML 模板 hello.html，并将 name 变量传递给模板。
		jsonify(data)：将 Python 字典转换为 JSON 响应。
		Response('Custom response with headers', status=200)：创建自定义响应对象，并设置响应头。
		make_response('Response with custom header')：创建响应对象并设置自定义头信息。
	处理错误： 可以在视图函数中处理异常或错误，或者通过 Flask 提供的错误处理机制来处理应用中的错误。
		使用 try-except：在视图函数中处理错误，并返回自定义错误消息和状态码。
		@app.errorhandler(404)：全局错误处理，定义处理 404 错误的函数。
	视图函数的装饰器：
		@app.before_request：在每个请求处理之前运行的函数。
		@app.after_request(response)：在每个请求处理之后运行的函数。
		@app.teardown_request(exception)：在请求结束后运行的函数，用于清理工作。
	视图函数返回的状态码：不仅可以返回内容，还可以指定 HTTP 状态码。
		return 'Everything is OK', 200
		return Response('An error occurred', status=500)


模板渲染：模板渲染允许你将动态内容插入到 HTML 页面中，使得应用能够生成动态的网页内容。
	创建模板：模板文件通常放在项目的 templates 文件夹中，Flask 会自动从这个文件夹中查找模板文件。
	继承模板：模板继承允许你创建一个基础模板，然后在其他模板中继承和扩展这个基础模板，避免重复的 HTML 代码。
		{% block title %} My Website {% endblock %}：定义可替换区域。
		{% extends "base.html" %}：表示继承 base.html。
	控制结构： Jinja2 提供了多种控制结构，用于在模板中实现条件逻辑和循环。
		{% if user %} {% else %} {% endif %}：条件控制。
		{% for item in items %}：for 循环。
	过滤器： 过滤器用于在模板中格式化和处理变量数据。
		{{ name|capitalize }}：将 name 变量的值首字母大写。
		{{ price|round(2) }}：将 price 变量的值四舍五入到小数点后两位。
	宏和模板包含： 宏是可重用的模板片段。模板包含允许你在一个模板中插入另一个模板的内容。
		{% macro macro_name(parameter) %} ... {% endmacro %}：创建宏。
		{% from "macros.html" import macro_name %}：导入宏。
	安全性： Jinja2 默认会对模板中的变量进行自动转义，防止 XSS 攻击。
	模板上下文： 视图函数中传递的变量成为模板的上下文，这些变量可以在模板中直接使用。


表单处理： Flask 提供了基本的表单处理功能，但通常结合 Flask-WTF 扩展来简化表单操作和验证。
	
	基本表单处理：Flask 提供了直接处理表单数据的方式，使用 request 对象来获取提交的数据。
	
	使用 Flask-WTF 扩展：Flask-WTF 是一个封装了 WTForms 的扩展，提供了表单处理和验证的功能，使得表单处理更加简洁和强大。
	
	表单验证：Flask-WTF 和 WTForms 提供了丰富的表单验证功能。你可以使用内置的验证器或自定义验证器来确保表单数据的有效性。
	
	文件上传：Flask 还支持处理文件上传。上传的文件可以通过 request.files 访问。 
		enctype="multipart/form-data"：指定表单数据的编码类型，支持文件上传。
		request.files.get('file')：获取上传的文件对象。
		file.save(f'uploads/{filename}')：将文件保存到指定目录。
	
	CSRF 保护：Flask-WTF 自动为表单提供 CSRF 保护。你需要配置一个密钥来启用 CSRF 保护，并在模板中包含隐藏的 CSRF 令牌。
		app.secret_key = 'your_secret_key'：配置 CSRF 保护。
	
数据库操作：
	Flask 提供了多种方式来与数据库进行交互，包括直接使用 SQL 和利用 ORM（对象关系映射）工具，如 SQLAlchemy。
	
	执行原始 SQL：
		db.session.execute("SELECT * FROM user")：执行原始 SQL 查询。
	
	使用 SQLAlchemy：
		SQLAlchemy 是一个强大的 ORM 库，可以简化数据库操作，通过 Python 对象与数据库表进行交互。
		Flask-SQLAlchemy 是 Flask 的一个扩展，用于集成 SQLAlchemy。
		配置 SQLAlchemy：
			app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///example.db'  # 使用 SQLite 数据库
			app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
		定义模型：模型是数据库表的 Python 类，每个模型类代表数据库中的一张表。
			db.Model：所有模型类需要继承自 db.Model。
			db.Column：定义模型的字段，指定字段的类型、是否为主键、是否唯一、是否可以为空等属性。
		创建数据库和表：在定义了模型后，你可以使用 SQLAlchemy 提供的方法来创建数据库和表。
			db.create_all()：创建所有在当前上下文中定义的模型对应的表。
		基本的 CRUD 操作：
			db.session.add(new_user)：将新用户对象添加到会话中。
			db.session.commit()：提交事务，将更改保存到数据库。
			User.query.all()：查询所有用户记录。
			User.query.get(user_id)：通过主键查询单个用户记录。
			db.session.delete(user)：删除用户记录，并提交事务。
		查询操作：
			基本查询：users = User.query.filter_by(username='john_doe').all()
			复杂查询：
				from sqlalchemy import or_
				users = User.query.filter(or_(User.username == 'john_doe', User.email == 'john@example.com')).all()
			排序和分页：users = User.query.order_by(User.username).paginate(page=1, per_page=10)
			filter_by()：根据字段值过滤记录。
			or_()：用于执行复杂的查询条件
			order_by()：按指定字段排序。
	
	使用 Flask-Migrate 进行迁移：Flask-Migrate 是一个用于数据库迁移的扩展，基于 Alembic，可以帮助你管理数据库的版本控制。
		配置 Flask-Migrate：migrate = Migrate(app, db)
			flask db init：初始化迁移环境。
			flask db migrate -m "message"：创建迁移脚本。
			flask db upgrade：应用迁移到数据库。
		
		或者使用 flask shell 初始化数据库：
			flask shell
			from app import db
			db.create_all()
			exit()
	
	Flask 中连接和操作 MySQL 数据库：在 Flask 中连接和操作 MySQL 数据库通常涉及到使用 SQLAlchemy 或直接使用 MySQL 的 Python 驱动。
		使用 Flask-SQLAlchemy 连接 MySQL：
			安装 Flask-SQLAlchemy 和 MySQL 驱动：pip install flask-sqlalchemy mysqlclient
			配置 Flask-SQLAlchemy：使用 SQLALCHEMY_DATABASE_URI 设置数据库连接 URI，格式为 mysql://username:password@localhost/dbname。
		直接使用 MySQL 的 Python 驱动：使用 mysql-connector-python 或 PyMySQL 库。
			安装 mysql-connector-python/PyMySQL：pip install mysql-connector-python/PyMySQL
			使用 mysql-connector-python 连接 MySQL:
				def get_db_connection():
					connection = mysql.connector.connect(host,user,password,database)
					return connection
				def add_user():
				connection = get_db_connection()
				cursor = connection.cursor()
				cursor.execute('INSERT INTO user (username, email) VALUES (%s, %s)', (name, email))
				connection.commit()
				# cursor = connection.cursor(dictionary=True)
				# cursor.execute('SELECT * FROM user')
				# users = cursor.fetchall()
				cursor.close()
				connection.close()
			使用 PyMySQL 连接 MySQL：
				def get_db_connection():
					connection = pymysql.connect(host=,user,password,database=,cursorclass=pymysql.cursors.DictCursor)
					return connection
				def add_user():
					with connection.cursor() as cursor:
						cursor.execute('INSERT INTO user (username, email) VALUES (%s, %s)', (name, email))
						connection.commit()
						# cursor.execute('SELECT * FROM user')
						# users = cursor.fetchall()
					connection.close()


蓝图 (Blueprints)：
	Flask 的蓝图（Blueprints）是一种组织代码的机制，允许你将 Flask 应用分解成多个模块。
	每个蓝图可以有自己的路由、视图函数、模板和静态文件，这样可以将相关的功能分组。
	
	蓝图是 Flask 提供的一种将应用程序分解为更小、更模块化组件的方式。
	它本质上是一个记录了操作（如路由、错误处理器等）的容器，这些操作会在蓝图注册到应用时被执行。
	
	创建一个名为 auth 的蓝图：
		auth_bp = Blueprint('auth', __name__)
	注册 auth 蓝图，将路由模块中定义的蓝图绑定到 Flask 应用实例，并将所有的路由前缀设置为 /auth：
		app.register_blueprint(
			auth_bp,
			url_prefix='/auth',
			static_folder='static',  # 可选的静态文件配置
			template_folder='templates'
		)
	使用蓝图中的模板和静态文件：蓝图中的模板和静态文件应放在蓝图的文件夹下的 templates 和 static 子文件夹中。
	在蓝图中使用请求钩子：蓝图支持请求钩子，例如 before_request 和 after_request，可以在蓝图中定义这些钩子来处理请求和响应。
	在蓝图中定义错误处理：蓝图也可以定义自己的错误处理函数。
		@auth.errorhandler(404)
		def page_not_found(error):
			return 'Page not found', 404


错误处理：
	处理 HTTP 错误：
		Flask 允许你定义针对特定 HTTP 状态码的错误处理函数。
		这些处理函数可以用于捕获并处理应用中的常见错误，如 404 页面未找到错误、500 服务器内部错误等。
	
	使用蓝图中的错误处理：
		蓝图（Blueprints）也可以定义自己的错误处理函数。这使得每个模块可以有自己的错误处理逻辑。
	
	处理自定义错误：
		你可以定义自定义异常类，并在应用中捕获和处理这些异常。这允许你在应用中实现更复杂的错误处理逻辑。
	
	全局错误处理：
		如果你希望在整个应用中处理所有未处理的异常，可以使用全局错误处理函数。这些处理函数可以捕获所有未被显式捕获的错误。
	
	使用 abort 函数：
		Flask 提供了一个 abort 函数，用于在视图函数中主动触发 HTTP 错误。这可以用于在特定条件下返回错误响应。
	
	渲染自定义错误页面：
		可以为每个错误码创建自定义的 HTML 页面，使得错误页面与应用的整体设计一致。


中间件和扩展：
	在 Flask 中，中间件和扩展是增强和扩展应用功能的两个关键机制。
	
	Flask 中间件
		Flask 的中间件是对请求和响应进行处理的钩子，通常用于在请求到达视图函数之前或在响应发送到客户端之前执行一些操作。
		中间件可以用于日志记录、请求修改、响应修改等。
		
		请求钩子:
			请求钩子允许你在处理请求的不同阶段插入代码，Flask 提供了几种钩子来处理请求生命周期的不同阶段。
			before_request：在每个请求处理之前执行。
			after_request：在每个请求处理之后执行。
			teardown_request：请求处理结束后，无论是否发生异常都会执行。
			before_first_request：仅在应用第一次处理请求之前执行。
		自定义中间件：
			Flask 还允许你创建自定义中间件类，这些中间件类可以在请求和响应处理的各个阶段进行操作。
	
	Flask 扩展：
		Flask 扩展是用于为 Flask 应用添加功能的插件。
		Flask 的扩展可以集成第三方库，提供例如数据库集成、表单处理、用户认证等功能。
		
		常见的 Flask 扩展：
			Flask-SQLAlchemy：集成 SQLAlchemy ORM，使数据库操作更方便。
			Flask-WTF：集成 WTForms 表单库，简化表单处理。
			Flask-Login：提供用户会话管理和用户认证功能。
			Flask-Migrate：用于数据库迁移的扩展，基于 Alembic。
			Flask-Mail：用于发送电子邮件。
		创建自定义扩展：
			如果现有的扩展不能满足你的需求，你可以创建自己的扩展。
			创建自定义扩展通常涉及到定义一个类，提供初始化配置和相关功能。


部署：
	Flask 部署是将你的 Flask 应用程序发布到生产环境中的过程，使其可以被用户访问。
	部署 Flask 应用涉及选择合适的服务器和环境配置。
	
	选择部署方式：
		Flask 应用通常需要一个 WSGI 服务器来处理 Python 应用程序和 HTTP 请求，通常与一个 Web 服务器（如 Nginx 或 Apache）配合使用。
		常见的 WSGI 服务器有：
			Gunicorn：一个流行的 WSGI 服务器，适用于 UNIX 系统。
			uWSGI：支持多种协议的高性能 WSGI 服务器，适用于 UNIX 和 Windows 系统。
			Waitress：一个简单且高效的 WSGI 服务器，适用于 Windows 系统。

代码要求：
	路由：动态路径转换
	接收请求数据：URL 参数、表单数据、查询参数等。
	返回响应：字符串、HTML、JSON、或自定义响应对象
	处理错误：使用 try-except、@app.errorhandler()、abort 函数，包括处理 HTTP 错误、使用蓝图中的错误处理、处理自定义错误、全局错误处理
	模板渲染：继承模板、条件控制、for循环、过滤器、宏和模板包含、crsf安全性
	表单数据处理： 基本表单处理、表单验证、文件上传、CSRF 保护
	数据库操作：使用 mysql-connector-python、PyMySQL、SQLAlchemy 连接本地 mysql 数据库，使用 Flask-Migrate 进行迁移，执行基本的 CRUD 操作，简单查询，复杂查询，排序和分页
	蓝图：三个蓝图，每个蓝图可以有自己的路由、视图函数、模板和静态文件
	中间件：使用钩子before_request、after_request(response)、teardown_request(exception)、before_first_request()，并且自定义一个简单中间件
	扩展：使用常见的 Flask 扩展 Flask-SQLAlchemy、Flask-WTF、Flask-Login、Flask-Migrate、Flask-Mail，并且自定义一个简单扩展

文件结构参考：
	HelloFlask/
	│
	├── harlen/
	│   ├── __init__.py
	│   ├── routes/
	│   ├── models/
	│   ├── templates/
	│   └── static/
	...
	├── config.py
	├── requirements.txt
	├── migrations/
	│   └── ...
	└── run.py

请按照要求给一个完整的代码示例，让我能复习一遍Flask的知识点，但是例子不要太复杂，简单易懂