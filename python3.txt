Python3 简介
	Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。
	Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。

	Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。
	Python 是交互式语言： 这意味着，您可以在一个 Python 提示符 >>> 后直接执行代码。
	Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。
	Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。

Python 特点
	1.易于学习：Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。
	2.易于阅读：Python代码定义的更清晰。
	3.易于维护：Python的成功在于它的源代码是相当容易维护的。
	4.一个广泛的标准库：Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。
	5.互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。
	6.可移植：基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。
	7.可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。
	8.数据库：Python提供所有主要的商业数据库的接口。
	9.GUI编程：Python支持GUI可以创建和移植到许多系统调用。
	10.可嵌入: 你可以将Python嵌入到C/C++程序，让你的程序的用户获得"脚本化"的能力。

基本数据类型：
	数字类型（Numeric Types）不可变
		int：整数
		float：浮点数
		bool：布尔值（本质是 int 的子类）
		complex：复数
	序列类型（Sequence Types）
		不可变序列：
			str：字符串
			bytes：字节序列
			tuples：元组
		可变序列：
			list：列表
			bytearray：可变字节序列
	集合类型（Set Types）
		set：可变集合
		frozenset：不可变集合
	映射类型（Mapping Types）
		dict：字典
	二进制类型（Binary Types）
		bytes：不可变字节序列
		bytearray：可变字节序列
		memoryview：内存视图
	其他特殊类型
		None：空值
		range：范围

Python3 解释器：
	Python解释器是执行Python代码的核心程序，其作用类似于一个"实时翻译官+执行引擎"。以下是专业且通俗的全面解释：

	Python解释器是一个动态代码执行系统，由以下核心组件构成：
		前端解析器
			词法分析：将代码拆解为token（如标识符、关键字）
			语法分析：生成抽象语法树（AST）
		编译器
			将AST转换为平台无关的字节码（.pyc文件）
		虚拟机（PVM）
			解释执行字节码指令
		运行时系统
			管理内存（引用计数+垃圾回收）
			处理异常和动态类型

	执行过程： 语法分析 -> 生成抽象语法树（AST）-> 分配内存 -> 编译字节码 -> PVM 执行代码

Python3 运算符：
	算术运算符：  +  -  *  /  %  **  //
	比较（关系）运算符：  ==  !=  >  <  >=  <=
	赋值运算符：  =  +=  -=  *=  /=  %=  **=  //=  :=
	逻辑运算符：  and  or  not
	位运算符：  &  |  ^  ~  <<  >>
	成员运算符：  in    not in
	身份运算符：  is    is not
	运算符优先级：
		()					括号（分组
		**					幂运算
		+x, -x, ~x			一元正负、按位取反
		*, /, //, %			乘、除、整除、取模
		+, -				加、减
		<<, >>				位移
		&					按位与
		^					按位异或
		|						按位或
		==, !=, >, <, >=, <=	比较运算
		is, is not				身份比较
		in, not in				成员检测
		not						逻辑非
		and						逻辑与
		or						逻辑或
		:=						海象运算符（Python 3.8+）

	is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。


Python3 数字(Number)：

	数学函数（math）：
		abs(x)						返回数字的绝对值
		ceil(x)						返回数字的上入整数，如math.ceil(4.1) 返回 5
		exp(x)						返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045
		fabs(x)						以浮点数形式返回数字的绝对值，如math.fabs(-10) 返回10.0
		floor(x)					返回数字的下舍整数，如math.floor(4.9)返回 4
		log(x)						如math.log(math.e)返回1.0,math.log(100,10)返回2.0
		log10(x)					返回以10为基数的x的对数，如math.log10(100)返回 2.0
		max(x1, x2,...)				返回给定参数的最大值，参数可以为序列。
		min(x1, x2,...)				返回给定参数的最小值，参数可以为序列。
		modf(x)						返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。
		pow(x, y)					x**y 运算后的值。
		round(x [,n])				返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。
		range(start, stop[, step])	生成一个数列，默认增量为1，返回的是一个迭代器对象，实现了惰性计算更节省内存
		sqrt(x)						返回数字x的平方根。

	随机函数（random）：
		choice(seq)							从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。
		randrange ([start,] stop [,step])	生成随机整数。
		random()							随机生成下一个实数，它在[0,1)范围内。
		randint(a, b)						返回一个介于 a 和 b 之间的整数（包括 a 和 b）。
		seed([x])							改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。
		shuffle(lst)						将序列的所有元素随机排序
		uniform(x, y)						随机生成下一个实数，它在[x,y]范围内。

	三角函数（math）：
		acos(x)			返回x的反余弦弧度值。
		asin(x)			返回x的反正弦弧度值。
		atan(x)			返回x的反正切弧度值。
		atan2(y, x)		返回给定的 X 及 Y 坐标值的反正切值。
		cos(x)			返回x的弧度的余弦值。
		hypot(x, y)		返回欧几里德范数 sqrt(x*x + y*y)。
		sin(x)			返回的x弧度的正弦值。
		tan(x)			返回x弧度的正切值。
		degrees(x)		将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0
		radians(x)		将角度转换为弧度

	数学常量
		pi		数学常量 pi（圆周率，一般以π来表示）
		e		数学常量 e，e即自然常数（自然常数）。

Python3 字符串：

	转义字符：
		\\			反斜杠（\）
		\'			单引号（'）
		\"			双引号（"）
		\a			响铃（ASCII 蜂鸣声）
		\b			退格（Backspace）
		\f			换页（Formfeed）
		\n			换行（Linefeed）
		\r			回车（Carriage Return）
		\t			水平制表符（Tab）
		\v			垂直制表符（Vertical Tab）
		\ooo		八进制表示的字符（如 \101 为 'A'）
		\xhh		十六进制表示的字符（如 \x41 为 'A'）
		\N{name}	Unicode 字符名（如 \N{COPYRIGHT SIGN} 为 '©'）
		\uhhhh		16位 Unicode 字符（如 \u00A9 为 '©'）
		\Uhhhhhhhh	32位 Unicode 字符（如 \U0001F600 为 '😀'）

	字符串运算符：
		+					字符串拼接（连接）
		*					字符串重复（后接整数表示重复次数）
		[]					通过索引获取字符（正向从0开始，负向从-1开始）
		[start:end]			切片操作（获取子字符串，包含start，不包含end）
		[start:end:step]	带步长的切片操作
		in					成员检查（判断子字符串是否存在）
		not in				非成员检查（判断子字符串是否不存在）
		%					格式化字符串（旧式格式化，如 "%d" % 10）
		==					字符串内容相等比较
		!=					字符串内容不相等比较
		< > <= >=			字符串按字典顺序比较（基于Unicode码点）
		f'' 或 f""			f-string前缀（支持内嵌表达式，Python 3.6+）
		r'' 或 r""			原始字符串前缀（忽略转义字符）
		b'' 或 b""			字节字符串前缀

	字符串格式化：
		%c	 格式化字符及其ASCII码
		%s	 格式化字符串
		%d	 格式化整数
		%u	 格式化无符号整型
		%o	 格式化无符号八进制数
		%x	 格式化无符号十六进制数
		%X	 格式化无符号十六进制数（大写）
		%f	 格式化浮点数字，可指定小数点后的精度
		%e	 用科学计数法格式化浮点数
		%E	 作用同%e，用科学计数法格式化浮点数
		%g	 %f和%e的简写
		%G	 %f 和 %E 的简写
		%p	 用十六进制数格式化变量的地址

	格式化操作符辅助指令:
		*		定义宽度或者小数点精度
		-		用做左对齐
		+		在正数前面显示加号( + )
		<sp>	在正数前面显示空格
		#		在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')
		0		显示的数字前面填充'0'而不是默认的空格
		%		'%%'输出一个单一的'%'
		(var)	映射变量(字典参数)
		m.n.	m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)

	format 格式化函数： "字符串{位置/名称}".format(参数)
		例如：
			"{} + {} = {}".format(2, 3, 5)       # '2 + 3 = 5'
			"{1} before {0}".format("B", "A")    # 'A before B'
			"{name} is {age}yo".format(name="Bob", age=30)  # 'Bob is 30yo'
			"{:.2%}".format(0.25)                # '25.00%'
		
		<		左对齐
		>		右对齐
		^		居中对齐
		=		符号后填充（仅数字）
		+		强制显示符号
		空格		正数前留空格
		,		千位分隔符
		_		千位分隔符（仅 f/g）

	f-string（Python 3.6+）： f"{变量/表达式}"
		以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去：
			name = "Charlie"
			f"{name=}"                           # "name='Charlie'"
			f"Area: {3.14 * 5**2:.1f}"           # 'Area: 78.5'
			f"Binary: {42:b}"                    # 'Binary: 101010'
		可以使用 = 符号来拼接运算表达式与结果（Python 3.8）：
			x = 1
			print(f'{x+1=}')   # Python 3.8
			x+1=2

	Unicode 字符串：
		在Python3中，所有的字符串都是Unicode字符串。
		
		字符串内建函数：
			capitalize()： 将字符串的第一个字符转换为大写
			center(width, fillchar)： 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格
			count(str, beg= 0,end=len(string))： 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数
			bytes.decode(encoding="utf-8", errors="strict")： 将字节序列解码为字符串，如果出错默认报一个ValueError 的异常
			endswith(suffix, beg=0, end=len(string))： 检查字符串是否以 suffix 结束，如果 beg 或者 end 指定则检查指定的范围内，返回 True 或 False
			expandtabs(tabsize=8)： 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 
			find(str, beg=0, end=len(string))： 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，检查是否包含在指定范围内，返回开始的索引值 或 -1
			index(str, beg=0, end=len(string))： 跟 find() 方法一样，只不过如果 str 不在字符串中会报一个异常
			isalnum()： 检查字符串是否由字母和数字组成，返回 True 或 False
			isalpha()： 检查字符串中的所有字符是否均为字母（Unicode 字母，包括但不限于 A-Z, a-z,中文字符），返回 True 或 False
			isdigit()： 检查字符串是否只包含数字，仅识别 ASCII 数字 (0-9) 和 部分 Unicode 数字（如全角数字１２３）
			islower()： 检查字符串中的字母字符是否全部为小写（非字母字符不影响结果）
			isnumeric()： 检查字符串是否只包含数字，识别 所有 Unicode 数字字符，包括汉字数字、罗马数字等
			isspace()： 检查字符串中的所有字符是否均为空白字符（非打印字符可能不生效）
			istitle()： 检查字符串是否符合标题化格式（每个单词首字母大写，其余小写）
			isupper()： 检查字符串中的字母字符是否全部为小写（非字母字符不影响结果）
			join(seq)： 将序列（如列表、元组）中的元素以指定字符串为分隔符连接成一个新字符串。它是高效拼接字符串的首选方式
			len(string)： 返回字符串长度
			ljust(width[, fillchar])： 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格
			lower()： 转换字符串中所有大写字符为小写
			lstrip()： 截掉字符串左边的空格或指定字符
			maketrans(x[, y[, z]])： 用于创建字符映射转换表，通常与 translate() 方法配合使用，实现高效的字符替换或删除操作。
				字典映射： maketrans({'a': '1', 'b': '2', 'c': '3'}) # 创建转换表：将 a→1, b→2, c→3
				字符串映射： maketrans('abc', 'ABC') # 创建转换表：将 a→A, b→B, c→C
				删除字符： maketrans('', '', 'abc') # 创建转换表：删除 a, b, c
				性能：translate() + maketrans() 比 str.replace() 更高效，适合大规模替换。
			max(str)： 返回字符串 str 中最大的字母
			min(str)： 返回字符串 str 中最小的字母
			replace(old, new [, max])： 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次
			rfind(str, beg=0,end=len(string))： 类似于 find()函数，不过是从右边开始查找
			rindex(str, beg=0, end=len(string))： 类似于 index()，不过是从右边开始
			rjust(width,[, fillchar])： 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串
			rstrip()： 删除字符串末尾的空格或指定字符
			split(sep="", maxsplit=string.count(str))： 将字符串按指定分隔符拆分成列表。它支持限制拆分次数 maxsplit，是处理文本数据的核心工具之一。
			splitlines([keepends])： 按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，否则保留
			startswith(substr, beg=0,end=len(string))： 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False
			strip([chars])： 删除字符串首尾的空格或指定字符
			swapcase()： 将字符串中的大小写字母互换（非字母字符不受影响）
			title()： 将字符串转换为标题化格式（每个单词的首字母大写，其余字母小写）
			translate(table)： 通过映射表批量替换或删除字符，table 转换表由 str.maketrans() 生成，或自定义字典
			upper()： 转换字符串中的小写字母为大写
			zfill (width)： 在字符串的左侧填充 0，使其达到指定长度。如果字符串本身长度已超过或等于指定宽度，则返回原字符串
			isdecimal()： 检查字符串中的所有字符是否均为十进制数字字符。它是判断字符串是否可转换为整数的安全方式之一

Python3 列表：
	列表可以被更新，删除，截取，拼接，嵌套，比较。
	
	删除列表： del list[index]
	
	列表函数：
		len(list)： 返回列表元素个数
		max(list)： 返回列表元素最大值
		min(list)： 返回列表元素最小值
		list(seq)： 将元组转换为列表
		append(obj)： 在列表末尾添加新的对象
		count(obj)： 统计某个元素在列表中出现的次数
		extend(seq)： 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表），返回值是 None。
		enumerate(iterable, start=0)： 在遍历可迭代对象（如列表、元组、字符串）时，同时获取元素的索引和值，每次迭代生成一个 (index, value)元组
		index(obj)： 从列表中找出某个值第一个匹配项的索引位置
		pop([index])： 移除并返回列表中指定位置的元素。若不指定位置，默认移除并返回最后一个元素
		remove(obj)： 移除列表中某个值的第一个匹配项
		reverse()： 原地反向列表中元素。
		list[::-1]： 反向列表中元素，返回新列表。
		sort(key=None, reverse=False)： 原地对列表进行排序。 支持自定义排序规则 key 和 升降序控制（默认 False，即升序）
		sorted(list)： 对列表进行排序，返回一个新的列表。
		zip()： 同时遍历两个或更多的序列，将各个序列中对应的元素打包成一个个元组，然后返回这些元组组成的迭代器。
		clear()： 清空列表
		copy()： 复制列表

Python3 元组：
	元组中的元素值是不允许修改和删除的，但是可以截取，组合。
	
	元组中只包含一个元素时，需要在元素后面添加逗号 , ，否则括号会被当作运算符使用： tup1 = (50,)
	
	所谓元组的不可变指的是元组所指向的内存中的内容不可变。

Python3 字典：
	键必须是唯一的，但值则不必。
	键必须是不可变的，如字符串、数字、元组，值可以取任何数据类型。
	字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。
	
	字典内置函数：
		clear()： 删除字典内所有元素
		copy()： 返回一个字典的浅复制
		fromkeys(iterable[, value])： 快速创建一个新字典，使用指定的序列（如列表、元组）作为键，并统一设置默认值
		get(key, default=None)： 安全地获取字典中的值。当键不存在时，不会引发 KeyError，而是返回指定的默认值（默认为 None）
		items()： 返回一个视图对象（view object），提供字典中所有键值对的动态视图
		keys()： 返回一个键的视图对象（view object），提供字典中所有键的动态访问接口
		setdefault(key, default=None)： 安全地获取或设置键值。若键存在，则返回对应的值；若键不存在，则设置该键的值为默认值（默认为 None），并返回默认值。
		update(dict2)： 把字典dict2的 键/值对 更新到dict里
		values()： 返回一个值的视图对象（view object），提供字典中所有值的动态访问接口
		pop(key[,default])： 安全地移除指定键并返回其值。如果键不存在，可以返回默认值或引发 KeyError
		popitem()： 随机移除并返回字典中的一个键值对。其核心特点是按照 LIFO（后进先出）的顺序移除键值对，即最末尾的键值对

Python3 集合：
	集合（set）是一个无序的不重复元素序列。
	集合可以进行交集、并集、差集，也可以对元素进行添加、移除、清空、计算、判断。
	
	集合内置方法：
		add()： 为集合添加元素
		clear()： 移除集合中的所有元素
		copy()： 拷贝一个集合
		difference(set)： 返回多个集合的差集
		difference_update(set): 移除两个集合中都存在的元素，在原集合上操作，无返回值
		discard()： 移除指定的集合元素，元素不存在时不会报错
		intersection(set1, set2 ...)： 返回多个集合的交集
		intersection_update(set1, set2 ...): 获取多个集合中的交集，在原集合上操作，无返回值
		isdisjoint(set)： 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False
		issubset(set)： 判断集合的所有元素是否都包含在指定集合中，如果是则返回 True，否则返回 False
		issuperset(set)： 判断集合是否包含指定集合的所有元素，如果是则返回 True，否则返回 False
		len()： 返回元素的个数
		pop()： 移除并返回集合中的一个随机元素，如果集合为空，会抛出 KeyError 异常
		remove()： 移除集合中的指定元素，元素不存在时会报错
		symmetric_difference(set)： 返回两个集合中不重复的元素集合，即会移除两个集合中都存在的元素
		symmetric_difference_update(set)： 移除两个集合中都存在的元素，并将另外一个集合中不同的元素插入到当前集合中，在原集合上操作，无返回值
		union(set1, set2...)： 返回两个集合的并集，重复的元素只会出现一次
		update(set)： 修改当前集合，可以添加新的元素或集合到当前集合中

Python3 条件控制：
	if...elif...else
	match...case

Python3 循环语句：
	while...(break/comtinue)
	while...else
	for...in
	for...in...else
	pass 占位语句


Python 推导式：
	Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。
	Python 支持各种数据结构的推导式：
		列表(list)推导式
		字典(dict)推导式
		集合(set)推导式
		元组(tuple)推导式： 返回的是生成器对象，python 没有专门的"元组推导式"，因为 "()"已经被生成器表达式占用，可以使用 tuple() 将生成器对象转成元组。

Python3 迭代器与生成器：
	迭代器（Iterator）：
		迭代器是任何实现了 __iter__() 和 __next__() 的对象。
		特性：
			状态保存： 迭代器是一个可以记住遍历位置的对象。
			单向前进： 每次调用 next() 或 for 循环都会推进迭代器，直到所有的元素被访问完结束，迭代器只能往前不会后退。
			耗尽即止： 遍历完成后，再次调用 next() 会触发 StopIteration，for 循环也会立即退出，是一次性的，再次迭代需要创建新的迭代器对象。
		
		使用迭代器有两个基本的方法： 创建迭代器 iter()， 输出下一个元素 next()。
		可以自己创建一个迭代器的类： 返回迭代器对象__iter__() 和 __next__()
		
		iter(obj) 的本质：
			def iter(obj):
				return obj.__iter__()  # 调用对象的 __iter__() 方法
		next(iter) 的本质：
			def next(iterator):
				return iterator.__next__()  # 调用迭代器的 __next__() 方法，用 StopIteration 异常用于标识迭代的完成
	
	生成器（generator）：
		生成器是用关键字 yield 或生成器表达式创建的特殊迭代器。
		生成器是一个返回迭代器的函数，只能用于迭代操作，生成器是迭代器的子集。
		
		特性：
			惰性计算： 动态生成，迭代过程中逐步产生值，而不是一次性返回所有结果。
			只能遍历一次： 每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。

Python with 关键字：
	with 是 Python 中用于上下文管理的关键字，它简化了资源（如文件、网络连接、锁等）的获取和释放，确保资源在使用后自动清理，避免内存泄漏或资源未释放的问题。
	
	语法： with expression [as variable]:
	
	上下文管理协议：
		with 语句背后是 Python 的上下文管理协议，该协议要求对象实现两个方法：
			__enter__()：进入上下文时调用，返回值赋给 as 后的变量
			__exit__()：退出上下文时调用，处理清理工作
	
	异常处理机制：
		__exit__(exc_type, exc_type, exc_tb) 接收三个参数：
			exc_type：异常类型
			exc_val：异常值
			exc_tb：异常追踪信息
		如果 __exit__() 返回 True，则表示异常已被处理，不会继续传播；返回 False 或 None，异常会继续向外传播。
	
	with的常见用途:
		文件操作
		数据库连接
		线程锁
		临时修改系统状态
	
	创建自定义的上下文管理器:
		在类中手动实现 __enter__和 __exit__
		使用 contextlib.contextmanager（推荐）
	
	Python 允许在单个 with 语句中管理多个资源。

Python3 assert 关键字：
	Python assert 用于判断一个表达式，在表达式条件为 false 的时候触发异常。
	断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况。
	
	语法格式： assert expression [, arguments]

Python3 函数：
	
	def 函数名（参数列表）:
		函数体
	
	对于参数在函数内的变化需要注意：
		可变类型：如list，函数内的增删改会影响到函数外的值，因为此时函数内外引用的是同一个对象，但是重新赋值不会影响，因为局部变量此时会指向一个新的对象。
		不可变类型：参数在函数内的修改不会影响到函数外的值和id，因为其不可变性质会导致局部变量被改变的时候已经指向了新的对象。

	调用函数时可使用的正式参数类型：
		必需参数： 须以正确的顺序传入函数，调用时的数量必须和声明时的一样。
		关键字参数： 允许函数调用时的参数顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。
		默认参数： 如果没有传递参数，则会使用默认参数。
		不定长参数： 需要一个函数能处理比当初声明时更多的参数，可以使用 *args_tuples 定义任意元素数量的元组， 使用 **args_dict 定义字典。
	
	关于函数定义和调用使用到的 * 解释：
		def f(*, x)：要求 x 必须通过关键字传入
		def f(*args)：接收任意数量位置参数（打包为元组）
		def f(**kwargs)：接收任意数量关键字参数（打包为字典）
		f(*iterable)：解包可迭代对象 tuples/list 为位置参数
		f(**dict)：解包字典为关键字参数
	
	匿名函数：
		lambda [arg1 [,arg2,.....argn]]:expression
		
		lambda：关键字，表示定义匿名函数。
		arg：可以接受多个参数，用逗号分隔。
		expression：只能有一个表达式（不能包含语句），其结果为返回值。
		
		注意：
			不能包含 return、for、while等语句。
			lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。
			经典搭配：map()、filter()、sorted(key=)。
		
		和 C++ 的内联函数相比：
			匿名函数是语言层面的语法糖，目的是让代码更简洁。
			内联函数是编译器优化手段，目的是提升性能。
	
	强制位置参数：
		def f(a, b, /, c, d, *, e, f):
			print(a, b, c, d, e, f)
		
		f(10, 20, 30, d=40, e=50, f=60)
		
		形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参。

Python3 装饰器：
	装饰器（Decorator）是一种高阶函数，它允许你在不修改原函数代码的情况下，动态地扩展或修改函数的行为。
	装饰器本质上是一个接收函数作为参数并返回一个新函数的函数。
	
	装饰器的应用场景：
		日志记录: 装饰器可用于记录函数的调用信息、参数和返回值。
		性能分析: 可以使用装饰器来测量函数的执行时间。
		权限控制: 装饰器可用于限制对某些函数的访问权限。
		缓存: 装饰器可用于实现函数结果的缓存，以提高性能。
	
	函数装饰器：
		装饰器的语法使用 @decorator_name 来应用在函数或方法上。
		如果原函数需要参数，可以在装饰器的 wrapper 函数中传递参数。
		装饰器本身也需要参数的话，可以使用装饰器工厂函数包在装饰器函数外面。
		多个装饰器堆叠从下往上依次作用。
	
	类装饰器：
		类装饰器有两种常见形式：
			函数形式的类装饰器（接收类作为参数，返回新类）
			类形式的类装饰器（实现 __call__ 方法，使其可调用）
	
	内置装饰器
		Python 提供了一些内置的装饰器，例如：
			@staticmethod: 
				将方法定义为静态方法，不需要实例化类即可调用。
				与类和实例无关，只是逻辑上属于该类，实现与类无关但逻辑上属于该类的功能
				工具函数，可通过类或实例调用。
				静态绑定，不会继承父类的 @staticmethod 方法。
			@classmethod: 
				将方法定义为类方法，自动接收类引用 cls 作为第一个参数。
				可访问类属性，能修改类状态（如类变量），管理类级别的状态或配置。
				替代构造函数，可通过类或实例调用。
				动态绑定，自动传递子类引用。
			@property: 将方法转换为属性，使其可以像属性一样访问。


Python3 数据结构：
	堆栈： 栈是一种后进先出（LIFO, Last-In-First-Out）数据结构，意味着最后添加的元素最先被移除。
	将列表当做栈使用：
		列表提供了一些方法，使其非常适合用于栈操作，特别是 append() 和 pop() 方法。
		用 append() 方法可以把一个元素添加到栈顶，用不指定索引的 pop() 方法可以把一个元素从栈顶释放出来。
	栈操作：
		压入（Push）: 将一个元素添加到栈的顶端。
		弹出（Pop）: 移除并返回栈顶元素。
		查看栈顶元素（Peek/Top）: 返回栈顶元素而不移除它。
		检查是否为空（IsEmpty）: 检查栈是否为空。
		获取栈的大小（Size）: 获取栈中元素的数量。
	
	队列： 队列是一种先进先出（FIFO, First-In-First-Out）的数据结构，意味着最早添加的元素最先被移除。 更推荐使用 collections.deque 实现队列而非 list。
	
	矩阵：通常用 嵌套列表 或 NumPy 数组实现。
	矩阵转置：np.transpose(matrix) 或 matrix.T
	矩阵加法：C = A + B
	矩阵乘法：点积 np.dot(A, B) 和 逐元素乘法 C = A * B


Python3 模块：
	Python 中的模块（Module）是一个包含 Python 定义和语句的文件，文件名就是模块名加上 .py 后缀。
	模块可以包含函数、类、变量以及可执行的代码。通过模块，我们可以将代码组织成可重用的单元，便于管理和维护。
	
	模块的作用
		代码复用：将常用的功能封装到模块中，可以在多个程序中重复使用。
		命名空间管理：模块可以避免命名冲突，不同模块中的同名函数或变量不会互相干扰。
		代码组织：将代码按功能划分到不同的模块中，使程序结构更清晰。
	
	模块的搜索路径：
		当 import 导入一个模块时，Python 会按照以下顺序查找模块：
			内建模块（Built-in Modules，内存中已加载）：是 Python 解释器自带的标准库模块，无需额外安装即可使用。
			冻结模块（frozen modules，如嵌入式 Python 中的模块）。
			sys.path 列表中的路径（按顺序）：
				当前目录。
				环境变量 PYTHONPATH 指定的目录。
				Python 标准库目录。
				.pth 文件中指定的目录。
	
	from package import item： 对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数、类或者变量。
	import a.b.c： 这种导入形式除了最后一项其他必须是包，最后一项可以是模块或者是包，但是不可以是类，函数或者变量的名字。
	from package import *： 
		导入语句遵循规则，如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用  的时候就把这个列表中的所有名字作为包内容导入。
		作为包的作者，可别忘了在更新包之后保证 __all__ 也更新了啊。
	
	无论是隐式的还是显式的相对导入都是从当前模块开始的。
	主模块的名字永远是"__main__"，一个Python应用程序的主模块，应当总是使用绝对路径引用。
	
	dir() 函数：
		内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回。
	
	标准模块： Python 本身带着一些标准的模块库。
	
	包： 包是一种管理 Python 模块命名空间的形式，采用"点模块名称"。
	
	__name__ 和 __main__ 通常用于控制代码的执行方式，尤其是在模块既可以作为独立脚本运行，也可以被其他模块导入时。
	
	__name__属性：
		用于表示当前模块的名称，每个模块都有一个 __name__ 属性，一个模块被另一个程序第一次引入时，其主程序将运行。

		__name__ 的值取决于模块是如何被使用的：
			当模块作为主程序运行时：__name__ 的值被设置为 "__main__"。
			当模块被导入时：__name__ 的值被设置为模块的文件名（不包括 .py 扩展名）
	
	__main__ 属性：
		用于表示当前模块是作为主程序运行的，__main__ 通常与 __name__ 变量一起使用，以确定模块是被导入还是作为独立脚本运行。
	
	if __name__ == "__main__"： 允许模块在被导入时不会执行某些代码。


Python3 输入和输出：
	Python两种输出值的方式: 表达式语句和 print() 函数。
	第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。
	
	输出格式美化：
		str.format()： 格式化输出值，!a 使用 ascii(), !s 使用 str(), !r 使用 repr()，可以用于在格式化某个值之前对其进行转化
		str()： 函数返回一个用户易读的表达形式。
		repr()： 产生一个解释器易读的表达形式。
	
	读取键盘输入：
		input() 函数接受一个标准输入数据，返回为 string 类型。
		input("prompt").split() 接收多个值
	
	读和写文件：
		open(filename, mode) 将会返回一个 file 对象。
		
		mode：
			r	只读。文件的指针将会放在文件的开头。这是默认模式。
			rb	以二进制格式打开一个文件用于只读。文件指针在开头。
			r+	读写。文件指针在开头。
			rb+	以二进制格式打开一个文件用于读写。文件指针在开头。
			w	写入。如果该文件已存在则打开文件，删除原有内容，并从开头开始编辑。如果不存在，创建新文件。
			wb	以二进制格式打开一个文件用于写入。如果该文件已存在则打开文件，删除原有内容，并从开头开始编辑。如果不存在，创建新文件。
			w+	读写。如果该文件已存在则打开文件，删除原有内容，并从开头开始编辑。如果不存在，创建新文件。
			wb+	以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，删除原有内容，并从开头开始编辑。如果不存在，创建新文件。
			a	追加。如果该文件已存在，文件指针将会放在文件的结尾，新内容将会被写入到已有内容之后。如果不存在，创建新文件。
			ab	以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾，新内容将会被写入到已有内容之后。如果不存在，创建新文件。
			a+	追加读写。如果该文件已存在，文件指针将会放在文件的结尾，文件打开时会是追加模式。如果不存在，创建新文件。
			ab+	以二进制格式打开一个文件用于追加读写。如果该文件已存在，文件指针将会放在文件的结尾。如果不存在，创建新文件。
	
			模式			r	r+	w	w+	a	a+
			读			+	+		+		+
			写				+	+	+	+	+
			创建					+	+	+	+
			覆盖					+	+		
			指针在开始	+	+	+	+		
			指针在结尾					+	+
	
		完整语法：
			open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
			file: 必需，文件路径（相对或者绝对路径）。
			mode: 可选，文件打开模式
			buffering: 缓冲策略。
				-1或省略：使用默认缓冲
				0：无缓冲，1：行缓冲
				>1：指定缓冲区大小（字节）
			encoding: 文件编码，一般使用utf8
			errors: 报错级别，编码错误处理方式。 'strict'- 遇到错误抛出异常（默认），'ignore'- 忽略错误，'replace'- 用替换标记替换错误字符
			newline: 换行符处理。
				None- 统一转换为 \n
				''- 不转换换行符
				'\n', '\r', '\r\n'- 指定换行符
			closefd: 是否关闭底层文件描述符
			opener: 自定义开启器，开启器的返回值必须是一个打开的文件描述符。
	
		文件对象的方法：
			f.read([size])： 读取一定数目的数据, 然后作为字符串或字节对象返回。
			f.readline()： 从文件中读取单独的一行。
			f.readlines([size])： 将返回该文件中包含的所有行。
			f.write()： 将 string 写入到文件中, 然后返回写入的字符数。 写入非字符串的内容, 需要先进行转换。
			f.writelines([sequence])： 将可迭代对象中的所有字符串依次写入文件，但不会自动添加换行符，写入的位置取决于文件的当前指针位置。
			f.tell()： 返回当前的文件指针的位置，文件指针表示从文件开头开始的字节数偏移量，返回一个整数。
			truncate([size])： 从文件的首行首字节开始截断，无 size 表示从当前位置截断；文件指针后面的所有字节被删除，Widnows 下换行代表2个字节。
			f.seek(offset, whence)： 用于移动文件指针到指定位置。 whence 是 0 表示开头, 是 1 表示当前位置, 是 2 表示文件的结尾，默认值为 0 。
				seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符
				seek(x,1) ： 表示从当前位置往后移动x个字符
				seek(-x,2)：表示从文件的结尾往前移动x个字符
			f.close()： 关闭文件并释放系统的资源。 更推荐使用 with 替代。
			f.fileno()： 返回一个整型的文件描述符(file descriptor FD 整型)，可用于底层操作系统的 I/O 操作。
						文件描述符是一个非负整数，是操作系统用来标识和跟踪打开文件的句柄。
						每个打开的文件都会被分配一个唯一的文件描述符。通常是 3,4,5,...（0、1、2 被标准流占用）。
			f.flush()： 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。
			f.isatty()： 检测文件是否连接到一个终端设备，如果是返回 True，否则返回 False。
	
	pickle 模块：
		python 的 pickle 模块实现了基本的数据序列和反序列化。
		pickle.dump(obj, file, [,protocol])： 序列化能够将程序中运行的对象信息保存到文件中去，永久存储。
		pickle.load(file)： 反序列化能够从文件中创建上一次程序保存的对象。
		
		obj：要序列化的 Python 对象（如列表、字典、自定义类实例等）。
		file：一个已打开的二进制文件对象（通常用 'wb' 'rb' 模式打开）。
		protocol（可选）：指定序列化协议版本（默认为最高版本）。
		
		protocol协议版本：
			协议版本		Python 版本支持		特点
			0			所有版本				人类可读的 ASCII 格式（兼容但慢）。
			1			所有版本				二进制格式（比 0 更快）。
			2			Python 2.3+			支持更多对象类型（如集合）。
			3			Python 3.0+			默认协议，支持字节对象优化。
			4			Python 3.4+			支持大型对象（>4GB）和内存优化。
			5			Python 3.8+			支持外存缓冲区和数据共享。

Python3 OS 文件/目录方法：
	os 模块是 Python 标准库中的一个重要模块，它提供了与操作系统交互的功能。
	通过 os 模块，你可以执行文件操作、目录操作、环境变量管理、进程管理等任务。
	os 模块是跨平台的，这意味着你可以在不同的操作系统（如 Windows、Linux、macOS）上使用相同的代码。
	
	os.getcwd()： 获取当前工作目录的路径。
	os.chdir(path)： 改变当前工作目录。
	os.listdir(path)： 列出指定目录中的所有文件和子目录，默认列出当前工作目录的内容。
	os.mkdir(path[,mode])： 创建一个新的目录，默认的 mode 是 0777，如果目录已经存在，会抛出 FileExistsError 异常。
	os.rmdir(path)： 删除一个空目录，如果目录不为空，会抛出 OSError 异常。
	os.removedirs(path)： 递归删除目录。
	os.remove(path)： 删除一个文件，如果文件不存在，会抛出 FileNotFoundError 异常。
	os.rename(src, dst)： 重命名文件或目录，src 是原路径，dst 是新路径。
	os.getenv(key)： 获取指定环境变量的值，如果环境变量不存在，返回 None。
	os.system(command)： 在操作系统的 shell 中执行命令，命令执行后，返回命令的退出状态。
	os.access(path, mode)： 使用当前的uid/gid尝试访问路径。
		os.F_OK: 测试path是否存在。
		os.R_OK:  测试path是否可读。
		os.W_OK： 测试path是否可写。
		os.X_OK： 测试path是否可执行。
	os.chmod(path, mode)： 更改文件或目录的权限。
	os.chown(path, uid, gid)： 更改文件所有者，如果不修改可以设置为 -1, 你需要超级用户权限来执行权限修改操作。
	os.close(fd)： 关闭文件描述符 fd。
	os.link(src, dst)： 创建硬链接，名为参数 dst，指向参数 src。
	os.open(file, flags[, mode])： 打开一个文件，并且设置需要的打开选项，模式参数mode参数是可选的，默认为 0777。
	os.readlink(path)： 返回软链接所指向的文件，可能返回绝对或相对路径。
	os.stat(path)： 在给定的路径上执行一个系统 stat 的调用。
	os.symlink(src, dst, target_is_directory=False)： 用于创建符号链接（symbolic link）。
	os.utime(path, times)： 设置指定路径文件最后的修改和访问时间。
	os.pardir(path)： 获取当前目录的父目录，以字符串形式显示目录名。
	os.replace(src, dst)： 替换原目录或文件。


Python3 错误和异常：
	Python 有两种错误很容易辨认：语法错误和异常。
	
	语法错误：解析错，是初学者经常碰到的。
	异常： 即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。大多数异常不会被程序处理，都以错误信息的形式返回。
	
	异常处理： 
		try/except：
			一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。
			一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。
			except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。
		try/except...else：
			else 子句将在 try 子句没有发生任何异常的时候执行。
			使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。
		try-finally：
			try-finally 语句无论是否发生异常都将执行最后的代码。
	
	抛出异常： raise [Exception [, args [, traceback]]]
		raise 参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。
	
	用户自定义异常：
		可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承。
		当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类。
	
	定义清理行为：
		try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。
		如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后被抛出。
	
	预定义的清理行为： 例如使用 with 打开文件，不论执行是否异常，都会 close。

Python3 面向对象：
	类：对象的蓝图模板，定义共有属性和方法
	对象：类的具体实例
	类变量：所有对象共享的数据
	实例变量：每个对象独有的数据（用self.修饰）
	方法：类中定义的函数
	继承：子类获取父类属性和方法（is-a关系）
	方法重写：子类修改继承的方法
	实例化：根据类创建对象的过程
	数据成员：类变量和实例变量的统称
	局部变量：方法内部定义的临时变量
	
	Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。
	对象可以包含任意数量和类型的数据。
	
	self 代表类的实例，而非类。 代表当前对象的地址，而 self.class 则指向类。
	类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。
	
	super 函数：
		super(type[, object-or-type])
		用于调用父类(超类)的一个方法。
		用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。
		MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。
		Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx
	
	类的私有属性和方法：
		__privateAttrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__privateAttrs。
	
	类的专有方法：
		对象生命周期相关
			构造与销毁
				__new__(cls[, ...])： 创建函数，对象创建时调用（类方法）
				__init__(self[, ...])： 构造函数，对象初始化时调用
				__del__(self)： 析构函数，对象销毁时调用
			内存管理
				__delattr__(self, name)： 删除属性时调用
				__getattr__(self, name)： 访问不存在的属性时调用
				__setattr__(self, name, value)： 设置属性时调用
				__dir__(self)： dir()调用时触发
		
		运算符重载
			比较运算符
				__eq__(self, other)： ==
				__ne__(self, other)： !=
				__lt__(self, other)： <
				__le__(self, other)： <=
				__gt__(self, other)： >
				__ge__(self, other)： >=
			
			算术运算符
				__add__(self, other)： +
				__sub__(self, other)： -
				__mul__(self, other)： *
				__truediv__(self, other)： /
				__floordiv__(self, other)： //
				__mod__(self, other)：%
				__pow__(self, other[, modulo])： **
			
			位运算符
				__and__(self, other)： &
				__or__(self, other)： |
				__xor__(self, other)： ^
				__lshift__(self, other)： <<
				__rshift__(self, other)： >>
		
		容器类型模拟
			序列类型
				__len__(self)： len()调用，获得长度
				__getitem__(self, key)： self[key] 访问，按照索引获取值
				__setitem__(self, key, value)： self[key] = value，按照索引赋值
				__delitem__(self, key)： del self[key]
				__contains__(self, item)：in 操作符
			迭代器协议
				__iter__(self)： 返回迭代器对象
				__next__(self)： 迭代下一个值
				__reversed__(self)： reversed()调用
		
		上下文管理 with 语句支持
			__enter__(self)： 进入上下文时调用
			__exit__(self, exc_type, exc_val, exc_tb)： 退出上下文时调用
		
		数值类型转换
			__int__(self)： int()
			__float__(self)： float()
			__bool__(self)： bool()
			__str__(self)： str()
			__repr__(self)： repr()打印，转换
			__bytes__(self)： bytes()
			__format__(self, format_spec)： format()
		
		属性访问控制
			描述符协议
				__get__(self, instance, owner)： 描述符获取
				__set__(self, instance, value)： 描述符设置
				__delete__(self, instance)： 描述符删除
			属性管理
				__getattribute__(self, name)： 所有属性访问都会调用
				__slots__： 限制实例属性
		
		类相关-元类操作
			__prepare__(metacls, name, bases, **kwargs)： 准备命名空间
			__instancecheck__(cls, instance)： isinstance()
			__subclasscheck__(cls, subclass)： issubclass()
		
		调用对象相关
			__call__(self[, args...])： 使实例可像函数一样调用
		
		协程相关-异步支持
			__await__(self)： await 表达式
			__aiter__(self)： 异步迭代器
			__anext__(self)： 异步迭代
			__aenter__(self)： 异步上下文管理器
			__aexit__(self)： 异步上下文管理器
		
		其他重要方法
			对象复制
				__copy__(self)： 浅拷贝
				__deepcopy__(self, memo)： 深拷贝
			数学运算
				__abs__(self)： abs()
				__neg__(self)： -x
				__pos__(self)： +x
				__invert__(self)： ~x
			矩阵乘法
				__matmul__(self, other)： @运算符（Python 3.5+）
	
	运算符重载 vs 方法重写:
		运算符重载（Operator Overloading）： 只能重载预定义的专有方法（双下划线方法）。
		方法重写（Method Overriding）： 可以重写任何方法，包括自定义方法。
	
	实例属性 VS 类属性：
	<实例属性>							<类属性>
	在 __init__方法或实例方法中定义			在类定义中直接定义
	存储在实例的 __dict__中				存储在类的 __dict__中
	随实例创建而创建，随实例销毁而销毁		随类创建而创建，随程序结束而销毁
	必须通过实例访问						可通过类或实例访问
	每个实例独立存储						所有实例共享同一份存储
	只影响当前实例							影响所有实例（除非被实例属性覆盖）

Python3 命名空间和作用域：
	命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。
	命名空间避免了名字冲突。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 比如文件夹命名。
	
	一般有三种命名空间：
		内置名称（built-in names）： Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。
		全局名称（global names）： 模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。
		局部名称（local names）： 函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）
	
	命名空间查找顺序： 局部的命名空间 -> 全局命名空间 -> 内置命名空间。
	
	命名空间的生命周期：命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。 因此，我们无法从外部命名空间访问内部命名空间的对象。
	
	作用域就是一个 Python 程序可以直接访问命名空间的正文区域。
	在一个 python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。
	
	有四种作用域：
		L（Local）： 最内层，包含局部变量，比如一个函数/方法内部。
		E（Enclosing）： 包含了非局部也非全局的变量。 比如两个嵌套函数，函数 A 里面包含了函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。
		G（Global）： 当前脚本的最外层，比如当前模块的全局变量。
		B（Built-in）： 包含了内建的变量/关键字等，最后被搜索。
	
	LEGB 规则（查找顺序： L –> E –> G –> B）：
		Local：当前函数的局部作用域。
		Enclosing：包含当前函数的外部函数的作用域（如果有嵌套函数）。
		Global：当前模块的全局作用域。
		Built-in：Python 内置的作用域。
	
	Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问。
	
	内部作用域想修改外部作用域的变量时，就要在内部用到 global 和 nonlocal 关键字来声明外部变量了。

Python 虚拟环境的创建（venv）：
	Python 虚拟环境（Virtual Environment）是一个独立的 Python 运行环境，它允许你在同一台机器上为不同的项目创建隔离的 Python 环境。每个虚拟环境都有自己的：
		Python 解释器
		安装的包/库
		环境变量
	
	创建虚拟环境： python3 -m venv 环境名称
	退出虚拟环境： deactivate
	删除虚拟环境： 只需删除对应的目录即可
	导出依赖： (.venv) pip freeze > requirements.txt
	从文件安装依赖: (.venv) pip install -r requirements.txt
	记录依赖：定期更新 requirements.txt 文件


Python 类型注解（Type Hints）:
	类型注解是一种为代码添加"说明标签"的技术，明确地指出变量、函数参数和返回值应该是什么数据类型。
	就像你给朋友寄一个包裹，如果你在包裹上写明"易碎品"和"向上箭头"，快递员就会知道要小心轻放、正确朝向。
	
	类型注解就是在代码中注明数据类型的语法，它的核心目的是：
		提高代码可读性：让他人（以及未来的你）一眼就能看懂代码的意图
		便于静态检查：在运行代码前，通过工具发现潜在的类型错误
		增强IDE支持：让代码编辑器提供更准确的自动补全和提示
	
	为什么需要类型注解？
		Python 以其动态类型特性而闻名——你不需要提前声明变量的类型，解释器会在运行时自动推断。这虽然灵活，但也带来了问题：
			代码难以理解：看到一个函数时，不清楚应该传入什么类型的数据
			隐藏的bug：可能不小心传入了错误类型，直到运行时才报错
			开发效率低：IDE无法提供准确的代码提示和补全
		类型注解通过提供可选的类型信息来解决这些问题，让你的代码更加健壮和可维护。
	
	变量注解：
		name: str = "Alice" 
		name: str 读作"变量 name 的类型是 str"。
	函数注解：
		def greet(first_name: str, last_name: str) -> str:
		这个函数执行后会返回一个字符串。
	列表、字典等容器类型：
		List[int]： 只包含整数的列表。
		Dict[str, int]： 键为字符串、值为整数的字典。
		Tuple[int, str, bool]： 包含整数、字符串、布尔值的元组。
		Set[str]： 只包含字符串的集合。
	可选类型（Optional）： 
		 Optional[str]： 当值可能是某种类型或者是 None 时使用。 等价于 Union[str, None]。
	联合类型（Union）： 当值可能是多种类型之一时使用。
	
	类型检查：
		Mypy 是最流行的 Python 类型检查器。
		现代 IDE（如 VS Code、PyCharm）都内置了类型检查支持。
	
	避免过度注解：
		过于明显的类型不需要注解。
		为复杂逻辑或公共接口添加注解。
	
	处理没有类型注解的第三方库：
		查看是否有对应的类型存根文件（通常叫 types-packageName）
		使用 Any 类型暂时绕过检查
		或者为常用函数添加自己的类型注解


Python3 标准库概览：
	系统与操作系统交互：
		os： 操作系统接口，包括文件/目录操作、环境变量管理、进程管理等。
		sys： 系统相关参数和函数，如命令行参数、模块搜索路径、解释器信息等。
		subprocess： 创建和管理子进程，执行外部命令并获取输出。
		platform： 获取平台标识信息，如操作系统、硬件架构、Python版本等。
		shutil： 高级文件操作，包括文件复制、移动、删除、归档等。
	
	文件与目录处理：
		pathlib： 面向对象的文件系统路径操作（Python 3.4+ 推荐使用）。
		glob： 文件路径模式匹配，支持通配符查找文件。
		fnmatch： Unix风格文件名模式匹配，支持简单的通配符匹配。
		tempfile： 安全地创建临时文件和目录，自动清理。
	
	日期和时间处理
		datetime： 日期和时间处理，支持日期计算、格式化等操作。
		time： 时间访问和转换，提供时间戳处理、睡眠等功能。
		calendar： 日历相关功能，如生成日历、判断闰年等。
	
	数据序列化与持久化：
		json： JSON编码和解码，支持Python对象与JSON格式转换。
		pickle： Python对象序列化，可将对象保存到文件或网络传输。
		sqlite3： SQLite数据库操作，内置轻量级数据库接口。
		csv： CSV文件读写，支持字典格式和自定义分隔符。
	
	数学与数值计算
		math： 数学函数，包括三角函数、对数、常数等。
		random： 生成随机数，支持多种分布类型的随机数生成。
		statistics： 统计计算，如均值、中位数、方差等。
		decimal： 十进制浮点运算，解决浮点数精度问题。
		fractions： 分数运算，支持分数表示和计算。
	
	网络与互联网
		urllib： URL处理，包括下载文件、发送POST请求、处理cookies等。
		socket: 底层网络接口，提供TCP/UDP通信能力。
		email： 邮件处理，支持邮件消息的解析和构建。
		ssl： SSL/TLS支持，为网络连接提供加密功能。
	
	并发与并行：
		threading： 线程管理，支持多线程编程。
		multiprocessing： 进程管理，支持多进程编程。
		concurrent.futures： 高级并发接口，提供线程池和进程池。
		asyncio： 异步I/O（Python 3.4+），支持协程和事件循环。
	
	数据压缩与归档
		zipfile： ZIP归档处理，支持创建、读取和修改ZIP文件。
		tarfile： TAR归档处理，支持读取和创建tar归档。
		gzip： GNU zip压缩，支持gzip格式文件的读写。
		bz2： bzip2压缩，支持bzip2格式文件的读写。
	
	调试与测试
		logging： 日志记录，支持多级别日志输出和日志配置。
		unittest： 单元测试框架，支持测试用例编写和运行。
		doctest： 文档测试，可以从文档字符串中提取测试用例。
		pdb： Python调试器，支持断点调试和代码检查。
	
	其他实用模块
		re： 正则表达式，支持强大的字符串模式匹配。
		argparse： 命令行参数解析，支持创建用户友好的命令行界面。
		itertools： 迭代器工具，提供多种迭代器生成函数。
		functools： 高阶函数工具，包括装饰器和函数包装器。
		collections： 扩展容器类型，提供更多数据结构如defaultdict、Counter等。
		typing： 类型提示支持（Python 3.5+），用于静态类型检查。


asyncio 异步编程：
	协程 (Coroutine)： 协程是 asyncio 的基础，使用 async/await语法定义。
	事件循环 (Event Loop)： 事件循环是 asyncio 的核心，负责调度和执行协程。
	
	事件循环管理：
		获取当前事件循环： loop = asyncio.get_event_loop()
		运行直到完成： loop.run_until_complete(coro)
		永久运行： loop.run_forever()
		关闭循环： loop.close()
		创建新循环并运行协程： asyncio.run(main())
		使用 uvloop 加速（需安装）： asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
	
	协程创建与控制：
		调用协程的三种方式：
			result = await my_coro()                    # 在 async 函数内，会暂停当前协程的执行，但不阻塞事件循环
			result = asyncio.run(my_coro())             # 在同步代码中，每次调用都会创建新事件循环，调用后自动清理，线程安全但不可嵌套调用
			result = loop.run_until_complete(my_coro()) # 使用现有循环，手动控制循环生命周期，能复用同一个循环执行多个任务
		创建任务： task = asyncio.create_task(coro())
		取消任务： task.cancel()
		检查状态：
			task.done()      # 是否完成
			task.cancelled() # 是否被取消
			task.result()    # 获取结果（如果完成）
	
	并发执行：
		同时运行多个协程：
			results = await asyncio.gather(
				coro1(),
				coro2(),
				coro3(),
				return_exceptions=True  # 不因异常中断
			)
		按完成顺序处理：
			for coro in asyncio.as_completed([coro1(), coro2()]):
				result = await coro
		等待多个任务完成
			done, pending = await asyncio.wait(
				[task1, task2],
				timeout=2.0,           # 超时设置
				return_when=asyncio.FIRST_COMPLETED  # 首个完成时返回
			)
	
	异步IO操作：
		延时操作： asyncio.sleep(1.5)
		TCP客户端： 
			reader, writer = await asyncio.open_connection('host', port)
			writer.write(data)
			await writer.drain()  # 确保数据发送
			writer.close()
		TCP服务器：
			async def handle_client(reader, writer):
				data = await reader.read(100)
				writer.write(data)
				await writer.drain()
			server = await asyncio.start_server(handle_client, '0.0.0.0', 8888)
	
	同步原语：
		锁 (Lock)： lock = asyncio.Lock()
		信号量 (Semaphore)： sem = asyncio.Semaphore(3)  # 最多3个并发
		事件 (Event)：
			event = asyncio.Event()
			await event.wait()  # 等待事件触发
			event.set()         # 触发事件
		队列 (Queue)：
			queue = asyncio.Queue(maxsize=10)
			await queue.put('item')
			item = await queue.get()
			queue.task_done()
	
	时间与调度：
		延迟执行： loop.call_later(5.0, callback)
		定时执行： loop.call_at(loop.time() + 5.0, callback)
		协程版定时器：
			await asyncio.sleep(5)
			callback()
	
	高级模式：
		异步上下文管理器：
			class AsyncResource:
				async def __aenter__(self):
					await self.connect()
					return self
				
				async def __aexit__(self, *exc):
					await self.close()
			
			async with AsyncResource() as res:
				await res.do_something()
		异步生成器：
			async def async_gen():
				for i in range(5):
					await asyncio.sleep(1)
					yield i

			async for item in async_gen():
				print(item)

Patsy 统计模型公式语言：
	Patsy 是一个 Python 库，专门用于描述统计模型和构建设计矩阵。它提供了一种简洁、直观的公式语言，特别适合在统计建模和数据分析中使用。
	
	公式语法： Patsy 使用类似 R 语言的公式语法来描述变量关系。
		
		响应变量 ~ 解释变量1 + 解释变量2 + ...
		例如： "y ~ x1 + x2"  # y 由 x1 和 x2 解释
	
		+	添加变量，y ~ a + b
		:	交互项，y ~ a:b
		*	所有交互项，y ~ a*b 等价于 y ~ a + b + a:b
		**	多项式交互，y ~ (a + b)**2等价于 y ~ a + b + a:b
	
	数据转换函数：
		 中心化 (center)： 减去均值使数据以0为中心。
			patsy.center(x)  # x - mean(x)
		标准化 (standardize)： 中心化后除以标准差。
			patsy.standardize(x)  # (x - mean(x)) / std(x)
		多项式转换：
			"y ~ poly(x, degree=3)"  # 正交多项式
		样条转换：
			"y ~ bs(x, df=4)"  # B样条基函数
		分类变量处理：
			"y ~ C(color)"  # 将color视为分类变量
		构建设计矩阵： 将数据框转换为适合统计建模的数值矩阵。
			y, X = patsy.dmatrices("y ~ x1 + x2", data=df)

PySpark 大规模数据处理框架：
	PySpark 是 Apache Spark 的 Python API，用于大规模分布式数据处理和分析。它结合了 Python 的易用性和 Spark 的强大分布式计算能力。
	
	Spark 架构：Driver Program (JVM) -> SparkContext -> Cluster Manager (YARN/Mesos/Standalone) -> Worker Nodes (Executors)
	
	核心组件
		SparkContext：与集群的连接入口
		RDD (Resilient Distributed Dataset)：弹性分布式数据集
		DataFrame：结构化数据抽象
		SparkSession：DataFrame 和 Dataset API 的入口点
	
		创建 SparkSession：
			spark = SparkSession.builder \
				.appName("MyApp") \
				.config("spark.sql.adaptive.enabled", "true") \
				.getOrCreate()
		获取 SparkContext：
			sc = spark.sparkContext
		
		创建 RDD：
			从集合创建： rdd = sc.parallelize([1, 2, 3, 4, 5], numSlices=4)  # 分4个分区
			从文件创建： text_rdd = sc.textFile("hdfs://path/to/file.txt")
		RDD 转换操作 (Transformations)：
			映射： rdd.map(lambda x: x * x)
			过滤： rdd.filter(lambda x: x % 2 == 0)
			扁平化： text_rdd.flatMap(lambda line: line.split(" "))
			去重： rdd.distinct()
			排序： rdd.sortBy(lambda x: x, ascending=False)
		RDD 行动操作 (Actions)：
			收集结果： rdd.collect()  # 返回所有元素到Driver
			计数： rdd.count()
			取前N个： rdd.take(3)
			聚合： rdd.reduce(lambda a, b: a + b)
			保存到文件： rdd.saveAsTextFile("output/")
		键值对 RDD：
			创建键值对RDD： rdd.map(lambda x: (x % 2, x))
			按键分组： pair_rdd.groupByKey()
			按键聚合： pair_rdd.reduceByKey(lambda a, b: a + b)
			排序按键： pair_rdd.sortByKey()
		
		创建 DataFrame：
			从 Pandas DataFrame：
				import pandas as pd
				pdf = pd.DataFrame({'name': ['Alice', 'Bob'], 'age': [25, 30]})
				df = spark.createDataFrame(pdf)
			从 RDD：
				rdd = sc.parallelize([('Alice', 25), ('Bob', 30)])
				df = rdd.toDF(['name', 'age'])
			从文件：
				df = spark.read.csv("data.csv", header=True, inferSchema=True)
				df = spark.read.json("data.json")
				df = spark.read.parquet("data.parquet")
		DataFrame 操作：
			选择列： df.select('name', 'age')
			过滤： df.filter(df.age > 25)
			分组聚合： df.groupBy('department').agg({'salary': 'avg', 'age': 'max'})
			排序： df.orderBy(df.age.desc())
			去重： df.distinct()
			添加列： df.withColumn('age_plus_10', df.age + 10)
			重命名列： df.withColumnRenamed('old_name', 'new_name')
		SQL 操作：
			创建临时视图：
				df.createOrReplaceTempView("people")
			执行 SQL 查询：
				result = spark.sql("""
					SELECT name, AVG(age) as avg_age 
					FROM people 
					WHERE age > 20 
					GROUP BY name
				""")
